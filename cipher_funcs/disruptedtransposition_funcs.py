# Import
try:
    from columnartransposition_funcs import encipher_columnartransposition
except ModuleNotFoundError:
    from .columnartransposition_funcs import encipher_columnartransposition
import random
import math
from string import ascii_lowercase as low, ascii_uppercase as up, digits

# Encipher
def encipher_disruptedtransposition(message, key, rows=None):
    
    '''
    encipher_disruptedtransposition(message, key, rows=None)
    
    Nulls are randomly inserted into the message to a sufficient length based 
    on the rows argument, the message and key are put into
    encipher_columnartransposition, then nulls are taken out.
    
    Arguments:
    message -- Message being enciphered
    key -- Columnar transposition key
    rows -- Number of rows for the columnar transposition array, if None or
            less than the message length when multiplied with the key length,
            it is automatically generated
    
    Steps:
    1. Non-letters/non-numbers are taken out of the key.
    2. If the key length times rows is less than the message length or rows is
       None, the number of rows is automatically generated by taking the
       smallest integer >= to the message length times 1.5 divided by the 
       key length. The area is now the key length times rows.
    3. Nulls are inserted randomly into the message until its length matches the
       area. The nulls are documented in a list called indices, and for
       visualization are put in an enumerated message.
    4. It is put through the function encipher_columnartransposition, and the
       nulls are taken out.
    
    Returns the cipher, enumerated message, and indices list.
    '''
    
    ## Variables
    # Message and key
    message = list(message)
    key = [x for x in key if x in low + up + digits]
    # General
    null = chr(0)
    indices, enumMessage = [], []
    enumMessage[:] = message
    # Rows
    rowLen = len(key)
    if not rows or rowLen * rows < len(message):
        rows = math.ceil(len(message) * 1.5 / rowLen)
    
    ## Encipher
    # Insert spaces
    while len(message) < rowLen * rows:
        message.insert(random.randint(0, len(message)), null)
    # Columnar transposition
    cipher = encipher_columnartransposition(message, key)
    cipher = ''.join(x for x in cipher if x != null)
    # Gather indices
    prev, delSpace = '', 0
    for lInd, letter in enumerate(message):
        if prev != null and letter == null:
            begin = lInd
        elif prev == null and letter != null:
            delSpace += lInd - begin
            indices.append((lInd - delSpace, lInd - begin))
        prev = letter
    # Enumerated cipher
    for index, spaces in reversed(indices):
        enumMessage.insert(index, '(' + str(spaces) + ')')
    enumMessage = ''.join(enumMessage)
    
    ## Return cipher, enumerated cipher, & indices
    return cipher, enumMessage, indices
